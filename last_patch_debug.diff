diff --git a/src/autopack/learned_rules.py b/src/autopack/learned_rules.py
index 0000000..1234567
--- a/src/autopack/learned_rules.py
+++ b/src/autopack/learned_rules.py
@@ -1,0 +1,383 @@
+"""Learned Rules Management for Autopack
+
+This module manages the discovery and promotion of learned rules through
+the promotion pipeline stages:
+1. NEW: Fix discovered during troubleshooting
+2. APPLIED: Fix was attempted
+3. CANDIDATE_RULE: Same pattern seen in >= 3 runs within 30 days
+4. RULE: Confirmed via recurrence, no regressions, human approved
+
+Configuration is loaded from config/models.yaml discovery_promotion section.
+"""
+
+import json
+import logging
+from dataclasses import dataclass, field, asdict
+from datetime import datetime, timedelta
+from enum import Enum
+from pathlib import Path
+from typing import Dict, List, Optional, Tuple
+
+import yaml
+
+logger = logging.getLogger(__name__)
+
+
+class DiscoveryStage(Enum):
+    """Stages in the rule promotion pipeline"""
+    NEW = "new"
+    APPLIED = "applied"
+    CANDIDATE_RULE = "candidate_rule"
+    RULE = "rule"
+
+
+@dataclass
+class RuleApplication:
+    """Record of a rule being applied"""
+    rule_id: str
+    run_id: str
+    applied_at: datetime
+    success: bool
+    regression_detected: bool = False
+    notes: str = ""
+
+
+@dataclass
+class LearnedRule:
+    """A learned rule discovered during troubleshooting"""
+    rule_id: str
+    pattern: str
+    fix_description: str
+    category: str
+    severity: str
+    stage: DiscoveryStage = DiscoveryStage.NEW
+    created_at: datetime = field(default_factory=datetime.now)
+    updated_at: datetime = field(default_factory=datetime.now)
+    applications: List[RuleApplication] = field(default_factory=list)
+    human_approved: bool = False
+    approval_notes: str = ""
+    metadata: Dict = field(default_factory=dict)
+
+    def to_dict(self) -> Dict:
+        """Convert to dictionary for serialization"""
+        data = asdict(self)
+        data['stage'] = self.stage.value
+        data['created_at'] = self.created_at.isoformat()
+        data['updated_at'] = self.updated_at.isoformat()
+        data['applications'] = [
+            {
+                **app,
+                'applied_at': app['applied_at'].isoformat() if isinstance(app['applied_at'], datetime) else app['applied_at']
+            }
+            for app in data['applications']
+        ]
+        return data
+
+    @classmethod
+    def from_dict(cls, data: Dict) -> 'LearnedRule':
+        """Create from dictionary"""
+        data = data.copy()
+        data['stage'] = DiscoveryStage(data.get('stage', 'new'))
+        data['created_at'] = datetime.fromisoformat(data['created_at']) if isinstance(data['created_at'], str) else data['created_at']
+        data['updated_at'] = datetime.fromisoformat(data['updated_at']) if isinstance(data['updated_at'], str) else data['updated_at']
+        data['applications'] = [
+            RuleApplication(
+                rule_id=app['rule_id'],
+                run_id=app['run_id'],
+                applied_at=datetime.fromisoformat(app['applied_at']) if isinstance(app['applied_at'], str) else app['applied_at'],
+                success=app['success'],
+                regression_detected=app.get('regression_detected', False),
+                notes=app.get('notes', '')
+            )
+            for app in data.get('applications', [])
+        ]
+        return cls(**data)
+
+
+@dataclass
+class PromotionConfig:
+    """Configuration for rule promotion criteria"""
+    min_runs_for_candidate: int = 3
+    window_days: int = 30
+    min_severity_for_candidate: str = "medium"
+    require_human_approval: bool = True
+
+    @classmethod
+    def from_yaml(cls, yaml_path: Path) -> 'PromotionConfig':
+        """Load promotion config from models.yaml"""
+        if not yaml_path.exists():
+            logger.warning(f"Config file not found at {yaml_path}, using defaults")
+            return cls()
+        
+        try:
+            with open(yaml_path, 'r') as f:
+                config = yaml.safe_load(f)
+            
+            discovery_config = config.get('discovery_promotion', {})
+            return cls(
+                min_runs_for_candidate=discovery_config.get('min_runs_for_candidate', 3),
+                window_days=discovery_config.get('window_days', 30),
+                min_severity_for_candidate=discovery_config.get('min_severity_for_candidate', 'medium'),
+                require_human_approval=discovery_config.get('require_human_approval', True)
+            )
+        except Exception as e:
+            logger.error(f"Error loading promotion config: {e}")
+            return cls()
+
+
+class LearnedRulesManager:
+    """Manages learned rules storage and promotion"""
+
+    SEVERITY_ORDER = ['low', 'minor', 'medium', 'high', 'critical']
+
+    def __init__(self, storage_path: Path, config_path: Optional[Path] = None):
+        """Initialize the learned rules manager
+        
+        Args:
+            storage_path: Path to the JSON file storing learned rules
+            config_path: Path to models.yaml for promotion config
+        """
+        self.storage_path = storage_path
+        self.config_path = config_path or Path('config/models.yaml')
+        self.promotion_config = PromotionConfig.from_yaml(self.config_path)
+        self.rules: Dict[str, LearnedRule] = {}
+        self._load_rules()
+
+    def _load_rules(self) -> None:
+        """Load rules from storage file"""
+        if self.storage_path.exists():
+            try:
+                with open(self.storage_path, 'r') as f:
+                    data = json.load(f)
+                self.rules = {
+                    rule_id: LearnedRule.from_dict(rule_data)
+                    for rule_id, rule_data in data.get('rules', {}).items()
+                }
+                logger.info(f"Loaded {len(self.rules)} learned rules")
+            except Exception as e:
+                logger.error(f"Error loading learned rules: {e}")
+                self.rules = {}
+        else:
+            self.rules = {}
+
+    def _save_rules(self) -> None:
+        """Save rules to storage file"""
+        self.storage_path.parent.mkdir(parents=True, exist_ok=True)
+        data = {
+            'rules': {
+                rule_id: rule.to_dict()
+                for rule_id, rule in self.rules.items()
+            },
+            'last_updated': datetime.now().isoformat()
+        }
+        with open(self.storage_path, 'w') as f:
+            json.dump(data, f, indent=2)
+
+    def add_rule(self, rule: LearnedRule) -> None:
+        """Add a new learned rule"""
+        self.rules[rule.rule_id] = rule
+        self._save_rules()
+        logger.info(f"Added learned rule: {rule.rule_id}")
+
+    def get_rule(self, rule_id: str) -> Optional[LearnedRule]:
+        """Get a rule by ID"""
+        return self.rules.get(rule_id)
+
+    def record_application(self, rule_id: str, run_id: str, success: bool,
+                          regression_detected: bool = False, notes: str = "") -> bool:
+        """Record that a rule was applied
+        
+        Args:
+            rule_id: The rule that was applied
+            run_id: The run where it was applied
+            success: Whether the application was successful
+            regression_detected: Whether a regression was detected
+            notes: Optional notes about the application
+            
+        Returns:
+            True if recorded successfully, False otherwise
+        """
+        rule = self.rules.get(rule_id)
+        if not rule:
+            logger.warning(f"Rule not found: {rule_id}")
+            return False
+
+        application = RuleApplication(
+            rule_id=rule_id,
+            run_id=run_id,
+            applied_at=datetime.now(),
+            success=success,
+            regression_detected=regression_detected,
+            notes=notes
+        )
+        rule.applications.append(application)
+        rule.updated_at = datetime.now()
+
+        # Auto-promote from NEW to APPLIED on first application
+        if rule.stage == DiscoveryStage.NEW:
+            rule.stage = DiscoveryStage.APPLIED
+            logger.info(f"Rule {rule_id} promoted to APPLIED stage")
+
+        self._save_rules()
+        return True
+
+    def count_rule_applications(self, rule_id: str, days: int) -> int:
+        """Count successful applications of a rule within a time window
+        
+        Args:
+            rule_id: The rule to count applications for
+            days: Number of days to look back
+            
+        Returns:
+            Number of successful applications within the window
+        """
+        rule = self.rules.get(rule_id)
+        if not rule:
+            return 0
+
+        cutoff = datetime.now() - timedelta(days=days)
+        return sum(
+            1 for app in rule.applications
+            if app.success and app.applied_at >= cutoff
+        )
+
+    def check_rule_regressions(self, rule_id: str) -> bool:
+        """Check if a rule has any regressions
+        
+        Args:
+            rule_id: The rule to check
+            
+        Returns:
+            True if regressions were detected, False otherwise
+        """
+        rule = self.rules.get(rule_id)
+        if not rule:
+            return False
+
+        return any(app.regression_detected for app in rule.applications)
+
+    def _severity_meets_minimum(self, severity: str, minimum: str) -> bool:
+        """Check if a severity level meets the minimum threshold"""
+        try:
+            severity_idx = self.SEVERITY_ORDER.index(severity.lower())
+            minimum_idx = self.SEVERITY_ORDER.index(minimum.lower())
+            return severity_idx >= minimum_idx
+        except ValueError:
+            logger.warning(f"Unknown severity level: {severity} or {minimum}")
+            return False
+
+    def is_promotion_eligible(self, rule: LearnedRule) -> Tuple[bool, str]:
+        """Check if a rule is eligible for promotion to the next stage
+        
+        Args:
+            rule: The rule to check
+            
+        Returns:
+            Tuple of (eligible, reason)
+        """
+        if rule.stage == DiscoveryStage.RULE:
+            return False, "Rule is already at final stage"
+
+        if rule.stage == DiscoveryStage.NEW:
+            return True, "NEW rules can be promoted to APPLIED after first application"
+
+        if rule.stage == DiscoveryStage.APPLIED:
+            # Check minimum applications
+            app_count = self.count_rule_applications(
+                rule.rule_id, 
+                self.promotion_config.window_days
+            )
+            if app_count < self.promotion_config.min_runs_for_candidate:
+                return False, f"Needs {self.promotion_config.min_runs_for_candidate} applications, has {app_count}"
+
+            # Check severity
+            if not self._severity_meets_minimum(
+                rule.severity, 
+                self.promotion_config.min_severity_for_candidate
+            ):
+                return False, f"Severity {rule.severity} below minimum {self.promotion_config.min_severity_for_candidate}"
+
+            return True, "Eligible for CANDIDATE_RULE promotion"
+
+        if rule.stage == DiscoveryStage.CANDIDATE_RULE:
+            # Check for regressions
+            if self.check_rule_regressions(rule.rule_id):
+                return False, "Rule has regressions"
+
+            # Check human approval requirement
+            if self.promotion_config.require_human_approval and not rule.human_approved:
+                return False, "Requires human approval"
+
+            return True, "Eligible for RULE promotion"
+
+        return False, "Unknown stage"
+
+    def promote_rule(self, rule_id: str) -> bool:
+        """Promote a rule to the next stage
+        
+        Args:
+            rule_id: The rule to promote
+            
+        Returns:
+            True if promoted successfully, False otherwise
+        """
+        rule = self.rules.get(rule_id)
+        if not rule:
+            logger.warning(f"Rule not found: {rule_id}")
+            return False
+
+        eligible, reason = self.is_promotion_eligible(rule)
+        if not eligible:
+            logger.warning(f"Rule {rule_id} not eligible for promotion: {reason}")
+            return False
+
+        stage_order = [
+            DiscoveryStage.NEW,
+            DiscoveryStage.APPLIED,
+            DiscoveryStage.CANDIDATE_RULE,
+            DiscoveryStage.RULE
+        ]
+        current_idx = stage_order.index(rule.stage)
+        if current_idx < len(stage_order) - 1:
+            rule.stage = stage_order[current_idx + 1]
+            rule.updated_at = datetime.now()
+            self._save_rules()
+            logger.info(f"Rule {rule_id} promoted to {rule.stage.value}")
+            return True
+
+        return False
+
+    def get_candidates_for_promotion(self) -> List[LearnedRule]:
+        """Get all rules that are ready for promotion review
+        
+        Returns:
+            List of rules eligible for promotion
+        """
+        candidates = []
+        for rule in self.rules.values():
+            eligible, _ = self.is_promotion_eligible(rule)
+            if eligible:
+                candidates.append(rule)
+        return candidates
+
+    def approve_rule(self, rule_id: str, notes: str = "") -> bool:
+        """Mark a rule as human-approved
+        
+        Args:
+            rule_id: The rule to approve
+            notes: Optional approval notes
+            
+        Returns:
+            True if approved successfully, False otherwise
+        """
+        rule = self.rules.get(rule_id)
+        if not rule:
+            logger.warning(f"Rule not found: {rule_id}")
+            return False
+
+        rule.human_approved = True
+        rule.approval_notes = notes
+        rule.updated_at = datetime.now()
+        self._save_rules()
+        logger.info(f"Rule {rule_id} approved")
+        return True
diff --git a/config/models.yaml b/config/models.yaml
index 1111111..2222222
--- a/config/models.yaml
+++ b/config/models.yaml
@@ -1,2 +1,3 @@
+# Autopack Model Configuration
 # Model configuration for Autopack
 # This file defines model selection, quotas, and escalation rules
 
@@ -154,3 +154,16 @@
     - claude-opus-4-5
   complexity_escalation:
     enabled: true
+
+# Discovery Promotion Pipeline Configuration
+# Controls how learned rules are promoted through stages:
+# NEW -> APPLIED -> CANDIDATE_RULE -> RULE
+discovery_promotion:
+  # Minimum successful applications to become a candidate
+  min_runs_for_candidate: 3
+  # Time window (days) for counting applications
+  window_days: 30
+  # Minimum severity level for candidate promotion
+  min_severity_for_candidate: medium
+  # Whether human approval is required for final RULE stage
+  require_human_approval: true
