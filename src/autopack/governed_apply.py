"""
Governed Apply System for Autopack

Safely applies code patches generated by the Builder to the filesystem.
Uses git apply for patch application with proper error handling.
"""

import subprocess
import logging
import re
from pathlib import Path
from typing import List, Tuple, Optional

logger = logging.getLogger(__name__)


class GovernedApplyPath:
    """
    Safely applies patches to the filesystem using git apply.

    This class provides:
    - Safe patch application with validation
    - Automatic cleanup of temporary files
    - Detailed error reporting
    - File verification
    """

    def __init__(self, workspace: Path):
        """
        Initialize GovernedApplyPath.

        Args:
            workspace: Path to the workspace root directory
        """
        if isinstance(workspace, str):
            workspace = Path(workspace)
        self.workspace = workspace

    def _repair_hunk_headers(self, patch_content: str) -> str:
        """
        Repair @@ hunk headers with incorrect line numbers and counts.

        LLMs often generate patches with wrong line numbers and counts. This function:
        1. For existing files, finds actual line number by matching context
        2. Recounts actual additions/deletions/context lines
        3. Rewrites the @@ headers with correct values

        Args:
            patch_content: Patch content that may have incorrect headers

        Returns:
            Patch with repaired headers
        """
        result_lines = []
        current_file = None
        current_file_content = None
        is_new_file = False

        lines = patch_content.split('\n')
        i = 0
        while i < len(lines):
            line = lines[i]

            # Track which file we're patching
            if line.startswith('--- a/'):
                file_path = line[6:]
                current_file = self.workspace / file_path
                is_new_file = False
                if current_file.exists():
                    try:
                        current_file_content = current_file.read_text(encoding='utf-8', errors='ignore').split('\n')
                    except Exception:
                        current_file_content = None
                else:
                    current_file_content = None
                result_lines.append(line)
                i += 1
                continue

            # For new files, track that it's a new file
            if line.startswith('--- /dev/null'):
                is_new_file = True
                current_file_content = None
                result_lines.append(line)
                i += 1
                continue

            # Repair @@ headers
            if line.startswith('@@'):
                # Parse the hunk header: @@ -OLD_START,OLD_COUNT +NEW_START,NEW_COUNT @@
                match = re.match(r'@@ -(\d+),?(\d*) \+(\d+),?(\d*) @@(.*)', line)
                if match:
                    suffix = match.group(5)

                    # Collect all hunk content lines first
                    hunk_content = []
                    j = i + 1
                    while j < len(lines) and not lines[j].startswith('@@') and not lines[j].startswith('diff --git'):
                        hunk_content.append(lines[j])
                        j += 1

                    # Remove trailing empty lines from hunk (common LLM artifact)
                    while hunk_content and (hunk_content[-1] == '' or hunk_content[-1] == ' '):
                        hunk_content.pop()

                    # Count actual lines in the hunk
                    additions = 0
                    deletions = 0
                    context = 0
                    for hunk_line in hunk_content:
                        if hunk_line.startswith('+') and not hunk_line.startswith('+++'):
                            additions += 1
                        elif hunk_line.startswith('-') and not hunk_line.startswith('---'):
                            deletions += 1
                        elif hunk_line.startswith(' '):
                            context += 1
                        elif hunk_line.startswith('\\ No newline'):
                            pass  # Don't count this

                    if is_new_file:
                        # New file: old is 0,0, new is 1,additions
                        new_count = additions
                        repaired_line = f'@@ -0,0 +1,{new_count} @@{suffix}'
                    elif current_file_content is not None:
                        # Existing file - try to find context position
                        old_count = deletions + context
                        new_count = additions + context

                        # Try to find actual start line by matching context
                        context_lines = []
                        k = i + 1
                        while k < len(lines) and not lines[k].startswith('@@') and not lines[k].startswith('diff --git'):
                            hunk_line = lines[k]
                            if hunk_line.startswith(' ') or hunk_line.startswith('-'):
                                context_lines.append(hunk_line[1:] if len(hunk_line) > 1 else '')
                            k += 1

                        actual_start = 1  # Default
                        if context_lines:
                            first_context = context_lines[0]
                            for line_num, file_line in enumerate(current_file_content, 1):
                                if file_line.strip() == first_context.strip():
                                    actual_start = line_num
                                    break

                        repaired_line = f'@@ -{actual_start},{old_count} +{actual_start},{new_count} @@{suffix}'
                    else:
                        # Can't determine file content, use counted values
                        old_start = int(match.group(1))
                        old_count = deletions + context
                        new_count = additions + context
                        repaired_line = f'@@ -{old_start},{old_count} +{old_start},{new_count} @@{suffix}'

                    if repaired_line != line:
                        logger.debug(f"Repaired hunk header: {line} -> {repaired_line}")
                    result_lines.append(repaired_line)
                    i += 1
                    continue

            result_lines.append(line)
            i += 1

        return '\n'.join(result_lines)

    def _fix_empty_file_diffs(self, patch_content: str) -> str:
        """
        Fix incomplete diff headers for empty new files.

        LLMs often generate incomplete diffs for empty __init__.py files like:
            diff --git a/path/__init__.py b/path/__init__.py
            new file mode 100644
            index 0000000..e69de29
            diff --git ...  (next file)

        This is missing the --- /dev/null and +++ b/path lines.

        Args:
            patch_content: Patch content that may have incomplete empty file diffs

        Returns:
            Patch with fixed empty file headers
        """
        lines = patch_content.split('\n')
        result = []
        i = 0

        while i < len(lines):
            line = lines[i]

            # Check for incomplete empty file pattern
            if line.startswith('index ') and 'e69de29' in line:
                # e69de29 is the git hash for empty content
                result.append(line)
                # Check if next line is another diff (missing --- and +++)
                if i + 1 < len(lines) and lines[i + 1].startswith('diff --git'):
                    # Find the file path from the previous diff --git line
                    for j in range(len(result) - 1, -1, -1):
                        if result[j].startswith('diff --git'):
                            # Extract file path: diff --git a/path b/path
                            parts = result[j].split()
                            if len(parts) >= 4:
                                file_path = parts[3]  # b/path
                                # Insert missing headers
                                result.append('--- /dev/null')
                                result.append(f'+++ {file_path}')
                                logger.debug(f"Fixed empty file diff for {file_path}")
                            break
                i += 1
                continue

            result.append(line)
            i += 1

        return '\n'.join(result)

    def _remove_existing_files_for_new_patches(self, patch_content: str) -> str:
        """
        Remove existing files that patches try to create as 'new file'.

        When a patch marks a file as 'new file mode' but the file already exists,
        delete the existing file so the patch can create it fresh.

        Args:
            patch_content: Patch content

        Returns:
            Unchanged patch content (side effect: removes conflicting files)
        """
        lines = patch_content.split('\n')
        i = 0

        while i < len(lines):
            line = lines[i]

            if line.startswith('diff --git'):
                # Extract file path: diff --git a/path b/path
                parts = line.split()
                if len(parts) >= 4:
                    file_path = parts[3][2:]  # Remove 'b/' prefix
                    full_path = self.workspace / file_path

                    # Check if next lines indicate new file mode
                    if i + 1 < len(lines) and lines[i + 1].startswith('new file mode'):
                        if full_path.exists():
                            # File exists but patch wants to create it - remove it
                            logger.info(f"Removing existing file for new file patch: {file_path}")
                            try:
                                full_path.unlink()
                            except Exception as e:
                                logger.warning(f"Failed to remove {file_path}: {e}")

            i += 1

        return patch_content

    def _sanitize_patch(self, patch_content: str) -> str:
        """
        Sanitize a patch to fix common formatting issues from LLM output.

        Common issues:
        - Lines in new file content missing the '+' prefix
        - Context lines missing the leading space
        - Hunk headers with incorrect line counts

        Args:
            patch_content: Raw patch content

        Returns:
            Sanitized patch content
        """
        # First fix empty file diffs
        patch_content = self._fix_empty_file_diffs(patch_content)

        lines = patch_content.split('\n')
        sanitized = []
        in_hunk = False
        in_new_file = False

        i = 0
        while i < len(lines):
            line = lines[i]

            # Track diff headers
            if line.startswith('diff --git'):
                sanitized.append(line)
                in_hunk = False
                in_new_file = False
                i += 1
                continue

            # Track new file mode
            if line.startswith('new file mode'):
                in_new_file = True
                sanitized.append(line)
                i += 1
                continue

            # Standard diff metadata lines
            if line.startswith(('index ', '---', '+++', 'similarity', 'rename ', 'deleted file')):
                sanitized.append(line)
                i += 1
                continue

            # Hunk header - we're now in a hunk
            if line.startswith('@@'):
                in_hunk = True
                sanitized.append(line)
                i += 1
                continue

            # Inside a hunk - content lines should start with +, -, or space
            if in_hunk:
                # Already properly formatted
                if line.startswith(('+', '-', ' ')) or line == '':
                    sanitized.append(line)
                # No newline at end of file marker
                elif line.startswith('\\ No newline'):
                    sanitized.append(line)
                # Line missing prefix - for new files, add +, otherwise add space (context)
                elif in_new_file or line.strip():
                    # For new files being created, all content lines should be additions
                    sanitized.append('+' + line)
                    logger.debug(f"Sanitized line (added +): {line[:50]}...")
                else:
                    sanitized.append(line)
            else:
                sanitized.append(line)

            i += 1

        return '\n'.join(sanitized)

    def apply_patch(self, patch_content: str) -> Tuple[bool, Optional[str]]:
        """
        Apply a patch to the filesystem.

        Args:
            patch_content: The patch content to apply (git diff format)

        Returns:
            Tuple of (success: bool, error_message: Optional[str])
            - (True, None) if patch applied successfully
            - (False, error_message) if patch failed with error details
        """
        if not patch_content or not patch_content.strip():
            logger.warning("Empty patch content provided")
            return True, None  # Empty patch is technically successful

        try:
            # Sanitize patch to fix common LLM output issues
            patch_content = self._sanitize_patch(patch_content)
            # Remove existing files that conflict with new file patches
            patch_content = self._remove_existing_files_for_new_patches(patch_content)
            # Repair incorrect line numbers and counts in hunk headers
            patch_content = self._repair_hunk_headers(patch_content)
            # Normalize line endings to LF and ensure trailing newline
            patch_content = patch_content.replace('\r\n', '\n').replace('\r', '\n')
            if not patch_content.endswith('\n'):
                patch_content += '\n'

            # Write patch to a temporary file
            patch_file = self.workspace / "temp_patch.diff"
            logger.info(f"Writing patch to {patch_file}")

            with open(patch_file, 'w', encoding='utf-8') as f:
                f.write(patch_content)

            # Also save a debug copy
            debug_patch_file = self.workspace / "last_patch_debug.diff"
            with open(debug_patch_file, 'w', encoding='utf-8') as f:
                f.write(patch_content)

            # First, try strict apply (dry run)
            logger.info("Checking if patch can be applied (dry run)...")
            check_result = subprocess.run(
                ["git", "apply", "--check", "temp_patch.diff"],
                cwd=self.workspace,
                capture_output=True,
                text=True
            )

            use_lenient_mode = False
            use_three_way = False
            if check_result.returncode != 0:
                error_msg = check_result.stderr.strip()
                logger.warning(f"Strict patch check failed: {error_msg}")

                # Try with lenient options that handle common LLM issues
                logger.info("Retrying with lenient mode (--ignore-whitespace -C1)...")
                lenient_check = subprocess.run(
                    ["git", "apply", "--check", "--ignore-whitespace", "-C1", "temp_patch.diff"],
                    cwd=self.workspace,
                    capture_output=True,
                    text=True
                )
                if lenient_check.returncode == 0:
                    use_lenient_mode = True
                    logger.info("Lenient mode check passed")
                else:
                    # Try 3-way merge which handles line number mismatches
                    logger.warning(f"Lenient mode also failed: {lenient_check.stderr.strip()}")
                    logger.info("Retrying with 3-way merge mode (-3)...")
                    three_way_check = subprocess.run(
                        ["git", "apply", "--check", "-3", "temp_patch.diff"],
                        cwd=self.workspace,
                        capture_output=True,
                        text=True
                    )
                    if three_way_check.returncode == 0:
                        use_three_way = True
                        logger.info("3-way merge mode check passed")
                    else:
                        # All git apply modes failed - try direct file write as last resort
                        logger.warning("All git apply modes failed, attempting direct file write fallback...")
                        success, files_written = self._apply_patch_directly(patch_content)
                        if success:
                            logger.info(f"Direct file write succeeded - {len(files_written)} files written")
                            for f in files_written:
                                logger.info(f"  - {f}")
                            if patch_file.exists():
                                patch_file.unlink()
                            return True, None
                        else:
                            logger.error(f"Direct file write also failed: {three_way_check.stderr.strip()}")
                            logger.error(f"Patch content:\n{patch_content[:500]}...")
                            if patch_file.exists():
                                patch_file.unlink()
                            return False, error_msg

            # Apply patch using git
            logger.info("Applying patch to filesystem...")
            if use_three_way:
                result = subprocess.run(
                    ["git", "apply", "-3", "temp_patch.diff"],
                    cwd=self.workspace,
                    capture_output=True,
                    text=True
                )
            elif use_lenient_mode:
                result = subprocess.run(
                    ["git", "apply", "--ignore-whitespace", "-C1", "temp_patch.diff"],
                    cwd=self.workspace,
                    capture_output=True,
                    text=True
                )
            else:
                result = subprocess.run(
                    ["git", "apply", "temp_patch.diff"],
                    cwd=self.workspace,
                    capture_output=True,
                    text=True
                )

            # Clean up temp file
            if patch_file.exists():
                patch_file.unlink()

            if result.returncode != 0:
                error_msg = result.stderr.strip()
                logger.error(f"Failed to apply patch: {error_msg}")
                return False, error_msg

            # Extract files that were modified
            files_changed = self._extract_files_from_patch(patch_content)
            logger.info(f"Patch applied successfully - {len(files_changed)} files modified")
            for file_path in files_changed:
                logger.info(f"  - {file_path}")

            return True, None

        except Exception as e:
            error_msg = str(e)
            logger.error(f"Exception during patch application: {error_msg}")
            # Clean up temp file if it exists
            patch_file = self.workspace / "temp_patch.diff"
            if patch_file.exists():
                patch_file.unlink()
            return False, error_msg

    def _apply_patch_directly(self, patch_content: str) -> Tuple[bool, List[str]]:
        """
        Apply patch by directly writing files - fallback when git apply fails.

        This extracts new file content from patches and writes them directly.
        ONLY works for new files (where --- /dev/null) - partial patches for
        existing files cannot be safely applied this way.

        Args:
            patch_content: Patch content

        Returns:
            Tuple of (success, list of files written)
        """
        files_written = []
        lines = patch_content.split('\n')
        i = 0

        while i < len(lines):
            line = lines[i]

            # Look for new file diffs
            if line.startswith('diff --git'):
                parts = line.split()
                if len(parts) >= 4:
                    file_path = parts[3][2:]  # Remove 'b/' prefix

                    # Check if this is a new file (has '--- /dev/null')
                    is_new_file = False
                    hunk_start = -1
                    j = i + 1
                    while j < len(lines) and not lines[j].startswith('diff --git'):
                        if lines[j].startswith('new file mode') or lines[j] == '--- /dev/null':
                            is_new_file = True
                        if lines[j].startswith('@@'):
                            hunk_start = j
                            break
                        j += 1

                    # Only process new files - for existing files, we can't safely
                    # apply partial patches without the original file content
                    if is_new_file and hunk_start >= 0:
                        content_lines = []

                        # Handle malformed hunk header where content is on same line
                        hunk_line = lines[hunk_start]
                        hunk_header_end = hunk_line.rfind('@@')
                        if hunk_header_end > 2:
                            after_header = hunk_line[hunk_header_end + 2:].lstrip()
                            if after_header:
                                content_lines.append(after_header)

                        k = hunk_start + 1
                        while k < len(lines) and not lines[k].startswith('diff --git'):
                            line_k = lines[k]
                            # Skip additional hunk headers
                            if line_k.startswith('@@'):
                                # Handle inline content after @@
                                hunk_end = line_k.rfind('@@')
                                if hunk_end > 2:
                                    after_hunk = line_k[hunk_end + 2:].lstrip()
                                    if after_hunk:
                                        content_lines.append(after_hunk)
                                k += 1
                                continue
                            # Extract added lines (for new files, everything after + is content)
                            if line_k.startswith('+') and not line_k.startswith('+++'):
                                content_lines.append(line_k[1:])
                            k += 1

                        if content_lines:
                            full_path = self.workspace / file_path
                            try:
                                full_path.parent.mkdir(parents=True, exist_ok=True)
                                with open(full_path, 'w', encoding='utf-8') as f:
                                    f.write('\n'.join(content_lines))
                                    if not content_lines[-1] == '':
                                        f.write('\n')
                                files_written.append(file_path)
                                logger.info(f"Directly wrote file: {file_path}")
                            except Exception as e:
                                logger.error(f"Failed to write {file_path}: {e}")
                    elif not is_new_file:
                        logger.warning(f"Skipping {file_path} - cannot apply partial patch to existing file via direct write")

            i += 1

        return len(files_written) > 0, files_written

    def _extract_files_from_patch(self, patch_content: str) -> List[str]:
        """
        Extract list of files modified from patch content.

        Args:
            patch_content: Git diff/patch content

        Returns:
            List of file paths that were modified
        """
        files = []
        for line in patch_content.split('\n'):
            # Look for diff --git a/path b/path lines
            if line.startswith('diff --git'):
                parts = line.split()
                if len(parts) >= 4:
                    # Extract file path from 'a/path/to/file'
                    file_path = parts[2][2:]  # Remove 'a/' prefix
                    files.append(file_path)
            # Also look for +++ b/path lines as backup
            elif line.startswith('+++') and not line.startswith('+++ /dev/null'):
                file_path = line[6:].strip()  # Remove '+++ b/'
                if file_path and file_path not in files:
                    files.append(file_path)

        return files

    def parse_patch_stats(self, patch_content: str) -> Tuple[List[str], int, int]:
        """
        Parse patch to extract statistics.

        Args:
            patch_content: Git diff/patch content

        Returns:
            Tuple of (files_changed, lines_added, lines_removed)
        """
        files_changed = self._extract_files_from_patch(patch_content)

        lines_added = 0
        lines_removed = 0

        for line in patch_content.split('\n'):
            # Count additions (lines starting with + but not +++)
            if line.startswith('+') and not line.startswith('+++'):
                lines_added += 1
            # Count removals (lines starting with - but not ---)
            elif line.startswith('-') and not line.startswith('---'):
                lines_removed += 1

        return files_changed, lines_added, lines_removed
