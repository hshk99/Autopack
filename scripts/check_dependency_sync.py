#!/usr/bin/env python3
"""
CI Check: Dependency Sync Validation

Ensures requirements.txt stays in sync with pyproject.toml by:
1. Running pip-compile deterministically on pyproject.toml
2. Comparing output to committed requirements.txt
3. Failing CI if drift detected

Usage:
    python scripts/check_dependency_sync.py

Exit codes:
    0: requirements.txt is in sync with pyproject.toml
    1: Drift detected - requirements.txt needs regeneration
    2: Runtime error (pip-tools not installed, files missing, etc.)
"""

import subprocess
import sys
import tempfile
from pathlib import Path


def main() -> int:
    """Check if requirements.txt is in sync with pyproject.toml."""
    repo_root = Path(__file__).parent.parent
    pyproject_path = repo_root / "pyproject.toml"
    requirements_path = repo_root / "requirements.txt"

    # Validate files exist
    if not pyproject_path.exists():
        print(f"[X] ERROR: pyproject.toml not found at {pyproject_path}", file=sys.stderr)
        return 2

    if not requirements_path.exists():
        print(f"[X] ERROR: requirements.txt not found at {requirements_path}", file=sys.stderr)
        return 2

    # Check if pip-tools is installed
    try:
        result = subprocess.run(
            ["pip-compile", "--version"],
            capture_output=True,
            text=True,
            check=False
        )
        if result.returncode != 0:
            print("[X] ERROR: pip-compile not found. Install pip-tools:", file=sys.stderr)
            print("  pip install pip-tools", file=sys.stderr)
            return 2
    except FileNotFoundError:
        print("[X] ERROR: pip-compile not found. Install pip-tools:", file=sys.stderr)
        print("  pip install pip-tools", file=sys.stderr)
        return 2

    # Run pip-compile deterministically to temp file
    with tempfile.NamedTemporaryFile(mode='w+', suffix='.txt', delete=False) as tmp_file:
        tmp_path = Path(tmp_file.name)

    try:
        print("ðŸ” Running pip-compile on pyproject.toml...")
        result = subprocess.run(
            [
                "pip-compile",
                "--generate-hashes",  # Deterministic output
                "--allow-unsafe",     # Include pip, setuptools, wheel
                "--output-file", str(tmp_path),
                str(pyproject_path)
            ],
            capture_output=True,
            text=True,
            cwd=repo_root,
            check=False
        )

        if result.returncode != 0:
            print("[X] ERROR: pip-compile failed:", file=sys.stderr)
            print(result.stderr, file=sys.stderr)
            return 2

        # Read both files for comparison
        compiled_lines = tmp_path.read_text(encoding='utf-8').splitlines()
        committed_lines = requirements_path.read_text(encoding='utf-8').splitlines()

        # Normalize: strip whitespace, filter out timestamp comments and path variations
        def normalize(lines):
            normalized = []
            for line in lines:
                stripped = line.strip()
                # Skip autogenerated timestamp comments
                if stripped.startswith("# This file is autogenerated") or \
                   stripped.startswith("# via https://github.com/jazzband/pip-tools"):
                    continue
                # Normalize pip-compile command header (paths may vary: absolute vs relative)
                if stripped.startswith("#    pip-compile"):
                    # Extract just the flags, ignore paths
                    continue
                # Normalize source comments that may have path variations
                # e.g., "# via autopack (c:/dev/Autopack/pyproject.toml)" vs "# via autopack (pyproject.toml)"
                if "#   autopack (" in stripped:
                    # Normalize to just "#   autopack (pyproject.toml)"
                    stripped = "#   autopack (pyproject.toml)"
                if "# via autopack (" in stripped:
                    # Normalize to just "# via autopack (pyproject.toml)"
                    stripped = "# via autopack (pyproject.toml)"
                normalized.append(stripped)
            return normalized

        compiled_normalized = normalize(compiled_lines)
        committed_normalized = normalize(committed_lines)

        # Compare
        if compiled_normalized == committed_normalized:
            print("[OK] SUCCESS: requirements.txt is in sync with pyproject.toml")
            return 0
        else:
            print("[X] DRIFT DETECTED: requirements.txt does NOT match pyproject.toml", file=sys.stderr)
            print("", file=sys.stderr)
            print("To fix this, regenerate requirements.txt:", file=sys.stderr)
            print("  pip-compile --generate-hashes --allow-unsafe pyproject.toml", file=sys.stderr)
            print("", file=sys.stderr)

            # Show diff for debugging
            print("Differences found:", file=sys.stderr)

            # Simple line-by-line diff
            compiled_set = set(compiled_normalized)
            committed_set = set(committed_normalized)

            only_in_compiled = compiled_set - committed_set
            only_in_committed = committed_set - compiled_set

            if only_in_compiled:
                print("", file=sys.stderr)
                print("Lines in compiled output but NOT in requirements.txt:", file=sys.stderr)
                for line in sorted(only_in_compiled)[:10]:  # Show first 10
                    print(f"  + {line}", file=sys.stderr)
                if len(only_in_compiled) > 10:
                    print(f"  ... and {len(only_in_compiled) - 10} more", file=sys.stderr)

            if only_in_committed:
                print("", file=sys.stderr)
                print("Lines in requirements.txt but NOT in compiled output:", file=sys.stderr)
                for line in sorted(only_in_committed)[:10]:  # Show first 10
                    print(f"  - {line}", file=sys.stderr)
                if len(only_in_committed) > 10:
                    print(f"  ... and {len(only_in_committed) - 10} more", file=sys.stderr)

            return 1

    finally:
        # Clean up temp file
        tmp_path.unlink(missing_ok=True)


if __name__ == "__main__":
    sys.exit(main())
