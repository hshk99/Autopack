{
  "run": {
    "run_id": "autopack-true-autonomy-p0p1-intention-plan-normalization",
    "safety_profile": "normal",
    "run_scope": "multi_tier",
    "token_cap": 420000,
    "max_phases": 2,
    "max_duration_minutes": 150
  },
  "tiers": [
    {
      "tier_id": "T0",
      "tier_index": 0,
      "name": "P0 - Project Intention Memory Contract",
      "description": "Define a first-class, compact, semantic 'Project Intention Memory' artifact contract and wire it into Autopack memory for end-to-end consistency."
    },
    {
      "tier_id": "T1",
      "tier_index": 1,
      "name": "P1 - Unstructured Plan â†’ Structured Plan Normalization",
      "description": "Tighten the gap so Autopack can reliably convert messy/unstructured plans into a safe structured plan (deliverables, scope, runnable validation, budgets), grounded in repo reality and guided by intention memory."
    }
  ],
  "phases": [
    {
      "phase_id": "F0.p0-project-intention-memory-contract",
      "phase_index": 0,
      "tier_id": "T0",
      "name": "Project Intention Memory: artifact + memory contract",
      "description": "Implement a compact, semantic 'Project Intention Memory' contract. Add run/project-scoped intention artifacts under .autonomous_runs (resolved via RunFileLayout) and ensure the intention anchor + structured intention payload can be written and retrieved via MemoryService planning collection. Keep the intention anchor small (<=2KB) for prompt injection. Ensure this is deterministic-first and token-efficient: stable hashing, bounded context, no file contents logged.",
      "task_category": "backend",
      "complexity": "medium",
      "builder_mode": "default",
      "scope": {
        "paths": [
          "src/autopack/file_layout.py",
          "src/autopack/autonomous_executor.py",
          "src/autopack/memory/memory_service.py",
          "src/autopack/memory/goal_drift.py",
          "src/autopack/config.py",
          "src/autopack/project_intention.py",
          "tests/autopack/test_project_intention.py",
          "docs/IMPLEMENTATION_PLAN_TRUE_AUTONOMY.md"
        ],
        "read_only_context": [
          {
            "path": "README.md",
            "reason": "North Star: True Autonomy + Project Intention Memory definition."
          },
          {
            "path": "docs/IMPLEMENTATION_PLAN_TRUE_AUTONOMY.md",
            "reason": "Defines intent artifact contract and phased roadmap; implement Phase 0 only in this phase."
          }
        ],
        "acceptance_criteria": [
          "Introduce a stable intention artifact contract (v1) that can be persisted under the run/project artifacts directory via RunFileLayout (no hardcoded paths).",
          "Create two intention artifacts: (1) a compact 'intent_anchor' (<= ~2KB) and (2) a structured intent JSON (v1) with: project_id, created_at, raw_input_digest, intent_anchor, intent_facts, non_goals, acceptance_criteria, constraints, toolchain_hypotheses, open_questions.",
          "Write intention artifacts without logging their full contents (token-light logs only).",
          "Wire MemoryService planning collection usage so the intention anchor is retrievable (bounded) during executor execution (do not increase prompt size beyond existing caps).",
          "Add deterministic tests validating: artifact paths resolved via RunFileLayout, anchor size cap enforced, digest stable, memory write+retrieve works when memory is enabled, and behavior degrades gracefully when memory is disabled."
        ],
        "test_cmd": "pytest -q tests/autopack/test_project_intention.py",
        "notes": [
          "Prefer deterministic-first creation. If an LLM is used, it must be strictly bounded and optional.",
          "Do NOT introduce token-heavy logs. Do NOT log file contents.",
          "Keep all new fields optional/backward compatible; default behavior unchanged unless explicitly enabled."
        ]
      }
    },
    {
      "phase_id": "F1.p1-unstructured-plan-to-structured-plan-normalization",
      "phase_index": 1,
      "tier_id": "T1",
      "name": "Normalize messy plans into safe structured execution plans",
      "description": "Tighten Autopack's ability to accept messy/unstructured plan inputs (notes, partial requirements, mixed formatting) and produce an execution-ready structured plan: deliverables, safe scope.paths, read_only_context, and at least one runnable validation step (tests/build/probe). Use deterministic-first parsing + repo grounding (RepoScanner/PatternMatcher/PreflightValidator). Use Project Intention Memory as semantic guidance throughout normalization. Allow LLM usage only as a last resort for low-confidence cases, and keep it token-capped and query-focused.",
      "task_category": "backend",
      "complexity": "high",
      "builder_mode": "default",
      "scope": {
        "paths": [
          "scripts/plan_hardening.py",
          "src/autopack/manifest_generator.py",
          "src/autopack/preflight_validator.py",
          "src/autopack/repo_scanner.py",
          "src/autopack/pattern_matcher.py",
          "src/autopack/context_selector.py",
          "src/autopack/autonomous_executor.py",
          "src/autopack/memory/memory_service.py",
          "src/autopack/project_intention.py",
          "src/autopack/plan_normalizer.py",
          "tests/autopack/test_plan_normalizer.py",
          "docs/IMPLEMENTATION_PLAN_TRUE_AUTONOMY.md"
        ],
        "read_only_context": [
          {
            "path": "README.md",
            "reason": "Defines autonomy expectations: accept unstructured plans, safe scope, runnable validation, token efficiency."
          },
          {
            "path": "docs/IMPLEMENTATION_PLAN_TRUE_AUTONOMY.md",
            "reason": "Phase 1 normalization design and acceptance criteria."
          },
          {
            "path": "templates/hardening_phases.json",
            "reason": "Existing planning templates to reuse where possible."
          },
          {
            "path": "templates/phase_defaults.json",
            "reason": "Existing defaults to apply during plan hardening."
          }
        ],
        "acceptance_criteria": [
          "Given an unstructured plan text input, Autopack produces a structured plan object with: (a) normalized deliverables list, (b) scope.paths as explicit file list or bounded directory entries, (c) read_only_context, (d) at least one runnable validation step (tests/build/probe), and (e) conservative budgets.",
          "Normalization is deterministic-first and repo-grounded (uses RepoScanner/PatternMatcher/PreflightValidator); LLM calls are optional and used only when confidence is low and questions are specific.",
          "Normalization uses Project Intention Memory as semantic guidance (retrieve intention anchor + planning context) and stores normalization decisions back into planning memory for later retrieval.",
          "If normalization cannot safely infer scope or runnable validation, it must fail fast with actionable errors (no silent fallbacks that waste tokens).",
          "Add deterministic tests covering: messy plan parsing, deliverable normalization, scope inference grounded in a synthetic repo layout, failure-fast behavior on missing validation, and token-safe bounded prompt/context usage."
        ],
        "test_cmd": "pytest -q tests/autopack/test_plan_normalizer.py",
        "notes": [
          "Focus on autonomy: minimize required human intervention by asking only the smallest necessary clarifying questions.",
          "Keep token usage bounded: cap any retrieval context, cap any LLM calls, and prefer deterministic parsing + repo scanning.",
          "Do not broaden write scope: all writes must remain in allowed_paths; follow governed apply constraints."
        ]
      }
    }
  ]
}


