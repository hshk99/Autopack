#!/usr/bin/env python3
"""Check dependency lock file determinism.

Verifies that lock files are present, valid, and match the current
dependency specifications.
"""

import json
import subprocess
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import Optional


@dataclass
class LockCheckResult:
    """Result of a lock file check."""

    name: str
    present: bool
    valid: bool
    up_to_date: bool
    message: str


def check_requirements_txt(repo_root: Path) -> LockCheckResult:
    """Check requirements.txt lock file."""
    lock_file = repo_root / "requirements.txt"
    pyproject = repo_root / "pyproject.toml"

    if not lock_file.exists():
        return LockCheckResult(
            name="requirements.txt",
            present=False,
            valid=False,
            up_to_date=False,
            message="requirements.txt not found",
        )

    if not pyproject.exists():
        return LockCheckResult(
            name="requirements.txt",
            present=True,
            valid=False,
            up_to_date=False,
            message="pyproject.toml not found",
        )

    # Check if lock file is valid (has pip-compile header)
    content = lock_file.read_text()
    if "pip-compile" not in content:
        return LockCheckResult(
            name="requirements.txt",
            present=True,
            valid=False,
            up_to_date=False,
            message="requirements.txt not generated by pip-compile",
        )

    # Check if lock file is up to date
    try:
        result = subprocess.run(
            [
                sys.executable,
                "-m",
                "piptools",
                "compile",
                "--dry-run",
                "--quiet",
                "--output-file=requirements.txt",
                "pyproject.toml",
            ],
            capture_output=True,
            text=True,
            cwd=repo_root,
            timeout=120,
        )
        if result.returncode != 0:
            # pip-compile might not be installed
            if "No module named piptools" in result.stderr:
                return LockCheckResult(
                    name="requirements.txt",
                    present=True,
                    valid=True,
                    up_to_date=True,  # Can't verify, assume OK
                    message="pip-tools not installed, skipping freshness check",
                )
            return LockCheckResult(
                name="requirements.txt",
                present=True,
                valid=True,
                up_to_date=False,
                message=f"pip-compile check failed: {result.stderr[:200]}",
            )

        # If dry-run produces output, lock file is out of date
        if result.stdout.strip() and "Would generate" in result.stdout:
            return LockCheckResult(
                name="requirements.txt",
                present=True,
                valid=True,
                up_to_date=False,
                message="requirements.txt needs regeneration",
            )

    except subprocess.TimeoutExpired:
        return LockCheckResult(
            name="requirements.txt",
            present=True,
            valid=True,
            up_to_date=True,  # Assume OK on timeout
            message="pip-compile check timed out, assuming OK",
        )
    except FileNotFoundError:
        return LockCheckResult(
            name="requirements.txt",
            present=True,
            valid=True,
            up_to_date=True,  # Can't verify, assume OK
            message="pip-tools not installed, skipping freshness check",
        )

    return LockCheckResult(
        name="requirements.txt",
        present=True,
        valid=True,
        up_to_date=True,
        message="OK",
    )


def check_requirements_dev_txt(repo_root: Path) -> LockCheckResult:
    """Check requirements-dev.txt lock file."""
    lock_file = repo_root / "requirements-dev.txt"

    if not lock_file.exists():
        return LockCheckResult(
            name="requirements-dev.txt",
            present=False,
            valid=False,
            up_to_date=False,
            message="requirements-dev.txt not found",
        )

    # Check if lock file is valid (has pip-compile header)
    content = lock_file.read_text()
    if "pip-compile" not in content:
        return LockCheckResult(
            name="requirements-dev.txt",
            present=True,
            valid=False,
            up_to_date=False,
            message="requirements-dev.txt not generated by pip-compile",
        )

    return LockCheckResult(
        name="requirements-dev.txt",
        present=True,
        valid=True,
        up_to_date=True,  # Full freshness check skipped for dev
        message="OK (freshness check skipped)",
    )


def check_package_lock_json(repo_root: Path) -> LockCheckResult:
    """Check package-lock.json lock file."""
    lock_file = repo_root / "package-lock.json"
    package_json = repo_root / "package.json"

    if not package_json.exists():
        return LockCheckResult(
            name="package-lock.json",
            present=False,
            valid=True,
            up_to_date=True,
            message="No package.json, skipping",
        )

    if not lock_file.exists():
        return LockCheckResult(
            name="package-lock.json",
            present=False,
            valid=False,
            up_to_date=False,
            message="package-lock.json not found",
        )

    # Validate JSON structure
    try:
        with open(lock_file) as f:
            data = json.load(f)

        if "lockfileVersion" not in data:
            return LockCheckResult(
                name="package-lock.json",
                present=True,
                valid=False,
                up_to_date=False,
                message="Invalid package-lock.json structure",
            )

        # Check lockfile version
        lock_version = data.get("lockfileVersion", 0)
        if lock_version < 2:
            return LockCheckResult(
                name="package-lock.json",
                present=True,
                valid=True,
                up_to_date=False,
                message=f"Old lockfile version {lock_version}, consider upgrading",
            )

    except json.JSONDecodeError as e:
        return LockCheckResult(
            name="package-lock.json",
            present=True,
            valid=False,
            up_to_date=False,
            message=f"Invalid JSON: {e}",
        )

    return LockCheckResult(
        name="package-lock.json",
        present=True,
        valid=True,
        up_to_date=True,
        message="OK",
    )


def check_platform_markers(repo_root: Path) -> LockCheckResult:
    """Check that platform markers are present for known OS-specific packages."""
    lock_file = repo_root / "requirements.txt"

    if not lock_file.exists():
        return LockCheckResult(
            name="platform_markers",
            present=False,
            valid=False,
            up_to_date=False,
            message="requirements.txt not found",
        )

    content = lock_file.read_text()

    # Check for expected platform markers
    expected_markers = [
        ("python-magic==", 'sys_platform != "win32"'),
        ("python-magic-bin==", 'sys_platform == "win32"'),
        ("pywin32==", 'sys_platform == "win32"'),
    ]

    missing_markers = []
    for package, marker in expected_markers:
        if package in content and marker not in content:
            # Package present but no marker
            missing_markers.append(f"{package} missing marker {marker}")

    if missing_markers:
        return LockCheckResult(
            name="platform_markers",
            present=True,
            valid=False,
            up_to_date=False,
            message=f"Missing platform markers: {', '.join(missing_markers)}",
        )

    return LockCheckResult(
        name="platform_markers",
        present=True,
        valid=True,
        up_to_date=True,
        message="OK",
    )


def main() -> int:
    """Run all lock file checks."""
    repo_root = Path(__file__).parent.parent.parent

    print("=" * 60)
    print("Dependency Lock File Verification")
    print("=" * 60)
    print()

    results = [
        check_requirements_txt(repo_root),
        check_requirements_dev_txt(repo_root),
        check_package_lock_json(repo_root),
        check_platform_markers(repo_root),
    ]

    all_passed = True

    for result in results:
        status = "✅" if (result.present and result.valid and result.up_to_date) else "❌"
        print(f"{status} {result.name}: {result.message}")

        if not result.present or not result.valid:
            all_passed = False
        # up_to_date failures are warnings, not errors
        if not result.up_to_date and result.valid:
            print(f"   ⚠️  Warning: {result.name} may need regeneration")

    print()
    print("=" * 60)

    if all_passed:
        print("✅ All lock file checks passed")
        return 0
    else:
        print("❌ Some lock file checks failed")
        return 1


if __name__ == "__main__":
    sys.exit(main())
