"""PR proposal artifacts and storage for run-local PR creation workflow.

Per IMPLEMENTATION_PLAN_PR_APPROVAL_PIPELINE.md, this module provides:
- PrProposal dataclass (frozen, deterministic representation of PR intent)
- PrProposalStorage (run-local artifact persistence under RunFileLayout)

Contract:
- Proposal generation is deterministic (no network calls)
- Proposal paths are canonical under RunFileLayout: <run_base>/pr/proposal.{json,md}
- Self-contained enough for human approval without terminal logs
"""

from __future__ import annotations

import json
from dataclasses import dataclass, asdict
from pathlib import Path
from typing import Any

from autopack.file_layout import RunFileLayout


@dataclass(frozen=True)
class PrProposal:
    """Immutable PR proposal artifact.

    Represents the canonical intent to create a PR, stored run-locally
    before approval is requested.
    """

    run_id: str
    phase_set: list[str]  # e.g. ["builder", "auditor", "quality_gate"]
    branch: str
    base_branch: str  # e.g. "main"
    title: str
    summary_md: str  # Markdown body for PR
    files_changed: list[str]
    loc_added: int
    loc_removed: int
    risk_score: int  # 0-100
    checklist: list[str]  # e.g. ["CI must be green", "Review routing snapshot"]
    metadata: dict[str, Any]  # commit SHAs, timestamps, links to run-local proofs

    def to_dict(self) -> dict[str, Any]:
        """Convert to JSON-serializable dict."""
        return asdict(self)

    @classmethod
    def from_dict(cls, data: dict[str, Any]) -> PrProposal:
        """Load from dict."""
        return cls(**data)


class PrProposalStorage:
    """Run-local storage for PR proposal artifacts."""

    @staticmethod
    def proposal_paths(run_id: str, project_id: str | None = None) -> tuple[Path, Path]:
        """Get canonical paths for proposal artifacts.

        Returns:
            (proposal.json path, proposal.md path)
        """
        layout = RunFileLayout(run_id=run_id, project_id=project_id)
        pr_dir = layout.base_dir / "pr"
        return (pr_dir / "proposal.json", pr_dir / "proposal.md")

    @staticmethod
    def save(proposal: PrProposal, *, project_id: str | None = None) -> tuple[Path, Path]:
        """Save proposal artifacts atomically.

        Args:
            proposal: PR proposal to save
            project_id: Optional project identifier

        Returns:
            (saved json path, saved md path)
        """
        json_path, md_path = PrProposalStorage.proposal_paths(proposal.run_id, project_id)

        # Ensure pr/ directory exists
        json_path.parent.mkdir(parents=True, exist_ok=True)

        # Write JSON (machine-readable)
        json_path.write_text(json.dumps(proposal.to_dict(), indent=2), encoding="utf-8")

        # Write Markdown (human-readable, PR body)
        md_content = _format_proposal_md(proposal)
        md_path.write_text(md_content, encoding="utf-8")

        return (json_path, md_path)

    @staticmethod
    def load(run_id: str, project_id: str | None = None) -> PrProposal | None:
        """Load proposal from run-local artifacts.

        Returns:
            PrProposal if found, else None
        """
        json_path, _ = PrProposalStorage.proposal_paths(run_id, project_id)
        if not json_path.exists():
            return None

        data = json.loads(json_path.read_text(encoding="utf-8"))
        return PrProposal.from_dict(data)


def _format_proposal_md(proposal: PrProposal) -> str:
    """Format PR proposal as Markdown body for gh pr create --body-file.

    Includes:
    - Summary
    - Risk assessment
    - File changes stats
    - Checklist
    - Run metadata
    """
    # File list (limit to 10)
    files_section = "\n".join(f"- `{f}`" for f in proposal.files_changed[:10])
    if len(proposal.files_changed) > 10:
        files_section += f"\n- _...and {len(proposal.files_changed) - 10} more_"

    # Checklist
    checklist_section = "\n".join(f"- [ ] {item}" for item in proposal.checklist)

    # Risk level emoji
    risk_emoji = "ðŸ”´" if proposal.risk_score >= 70 else "âš ï¸" if proposal.risk_score >= 40 else "âœ…"

    md = f"""# {proposal.title}

## Summary
{proposal.summary_md}

## Changes
- **Files Changed**: {len(proposal.files_changed)}
- **Lines Added**: {proposal.loc_added}
- **Lines Removed**: {proposal.loc_removed}
- **Risk Score**: {risk_emoji} {proposal.risk_score}/100

### Affected Files
{files_section}

## Pre-Merge Checklist
{checklist_section}

## Run Metadata
- **Run ID**: `{proposal.run_id}`
- **Branch**: `{proposal.branch}`
- **Base**: `{proposal.base_branch}`
- **Phases**: {', '.join(f'`{p}`' for p in proposal.phase_set)}

{_format_metadata_section(proposal.metadata)}

---
*Generated by Autopack PR Approval Pipeline*
"""
    return md


def _format_metadata_section(metadata: dict[str, Any]) -> str:
    """Format metadata dict as Markdown key-value list."""
    if not metadata:
        return ""

    lines = []
    for key, value in metadata.items():
        # Convert snake_case to Title Case
        label = key.replace("_", " ").title()
        lines.append(f"- **{label}**: `{value}`")

    return "\n".join(lines)
